/* eslint-env node */
import 'dotenv/config';
import fs from 'node:fs/promises';
import path from 'node:path';

/**
 * Konfiguration
 */
const SHOP_DOMAIN =
  process.env.SHOPIFY_STORE_DOMAIN ||
  process.env.PUBLIC_STORE_DOMAIN ||
  process.env.SHOP_DOMAIN;

const ADMIN_TOKEN =
  process.env.SHOPIFY_ADMIN_TOKEN || process.env.ADMIN_API_TOKEN;

const API_VERSION = process.env.ADMIN_API_VERSION || '2025-01';

// Wohin schreiben (relativ zum Projektroot starten)
const OUT_DIR = path.resolve('app/graphql/product');
const ALL_FILE = path.join(OUT_DIR, 'metafield-defs-ALL.json');
const PRODUCT_FILE = path.join(OUT_DIR, 'product-metafield-defs.json');
const FRAGMENT_FILE = path.join(OUT_DIR, 'product-metafields.fragment.graphql');

if (!SHOP_DOMAIN || !ADMIN_TOKEN) {
  console.error('❌ Fehlt SHOP_DOMAIN oder ADMIN_TOKEN.');
  console.error({
    SHOPIFY_STORE_DOMAIN: process.env.SHOPIFY_STORE_DOMAIN,
    PUBLIC_STORE_DOMAIN: process.env.PUBLIC_STORE_DOMAIN,
    SHOP_DOMAIN: process.env.SHOP_DOMAIN,
    SHOPIFY_ADMIN_TOKEN: !!process.env.SHOPIFY_ADMIN_TOKEN,
    ADMIN_API_TOKEN: !!process.env.ADMIN_API_TOKEN,
  });
  process.exit(1);
}

const endpoint = `https://${SHOP_DOMAIN}/admin/api/${API_VERSION}/graphql.json`;

/**
 * Admin API Query – MetafieldDefinitions pro OwnerType
 */
const query = `
  query defs($ownerType: MetafieldOwnerType!, $cursor: String) {
    metafieldDefinitions(first: 100, ownerType: $ownerType, after: $cursor) {
      edges {
        cursor
        node {
          namespace
          key
          name
          type { name }
          access { storefront }
          # nützlich zur Nachverfolgung:
          ownerType
        }
      }
      pageInfo { hasNextPage }
    }
  }
`;

/**
 * GQL Helfer
 */
async function gql(variables = {}) {
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'X-Shopify-Access-Token': ADMIN_TOKEN,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({query, variables}),
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}: ${await res.text()}`);
  const json = await res.json();
  if (json.errors) throw new Error(JSON.stringify(json.errors));
  return json.data;
}

/**
 * Für welche OwnerTypes exportieren?
 * (Liste kann bei Bedarf erweitert werden)
 */
const OWNER_TYPES = ['PRODUCT', 'PRODUCTVARIANT', 'COLLECTION', 'SHOP'];

/**
 * Main
 */
async function run() {
  await fs.mkdir(OUT_DIR, {recursive: true});

  /** 1) Alle Definitionen über mehrere OwnerTypes sammeln */
  const allDefs = [];
  for (const ownerType of OWNER_TYPES) {
    let cursor = null;
    // Seite für Seite
    for (;;) {
      const data = await gql({ownerType, cursor});
      const page = data.metafieldDefinitions;
      const nodes = page.edges.map((e) => ({
        ...e.node,
        // ownerType ist bei älteren APIs nicht immer gesetzt → anreichern
        ownerType,
      }));
      allDefs.push(...nodes);

      if (!page.pageInfo.hasNextPage) break;
      cursor = page.edges.at(-1).cursor;
    }
  }

  // Schreiben: kompletter Dump
  await fs.writeFile(ALL_FILE, JSON.stringify(allDefs, null, 2), 'utf8');

  /** 2) Nur PRODUCT-Definitionen herausfiltern */
  const productDefs = allDefs.filter((d) => d.ownerType === 'PRODUCT');

  await fs.writeFile(
    PRODUCT_FILE,
    JSON.stringify(productDefs, null, 2),
    'utf8',
  );

  /** 3) Fragment bauen – nur storefront-freigegeben, Namespace "custom" zuerst */
  const productStorefront = productDefs.filter(
    (d) => d?.access?.storefront === 'PUBLIC_READ',
  );

  // Reihenfolge: zuerst custom, dann der Rest – nur der Lesbarkeit halber
  const sorted = [
    ...productStorefront.filter((d) => d.namespace === 'custom'),
    ...productStorefront.filter((d) => d.namespace !== 'custom'),
  ];

  const identifiers = sorted
    .map(
      (d) =>
        `        {namespace: "${d.namespace}", key: "${d.key}"}${
          d.type?.name ? `  # ${d.type.name}` : ''
        }`,
    )
    .join('\n');

  const fragment = `# Generated by graphql/product/export-product-metafields.mjs
# Store: ${SHOP_DOMAIN}
# API: ${API_VERSION}
# OwnerType: PRODUCT
# Hinweis: nur Definitionen mit storefront: PUBLIC_READ

fragment ProductCustomMetafields on Product {
  # Liefert eine Liste von Metafeldern (Einträge können null sein,
  # wenn am Produkt kein Wert gesetzt ist)
  metafields(identifiers: [
${identifiers}
  ]) {
    namespace
    key
    type
    value

    # Referenzen (Dateien, Media, Metaobjekte etc.)
    reference {
      __typename
      ... on Metaobject { id type handle fields { key type value } }
      ... on MediaImage { image { url altText } }
      ... on Video { sources { url mimeType } }
      ... on Model3d { sources { url mimeType } }
      ... on GenericFile { url mimeType }
    }
  }
}
`;

  await fs.writeFile(FRAGMENT_FILE, fragment, 'utf8');

  // Log
  const byNs = productStorefront.reduce((acc, d) => {
    acc[d.namespace] = (acc[d.namespace] || 0) + 1;
    return acc;
  }, {});
  console.log('✅ Export fertig');
  console.log('  →', path.relative(process.cwd(), ALL_FILE));
  console.log('  →', path.relative(process.cwd(), PRODUCT_FILE));
  console.log('  →', path.relative(process.cwd(), FRAGMENT_FILE));
  console.log('Produkt-Defs (storefront):', productStorefront.length);
  console.log('Namespaces:', byNs);
}

run().catch((err) => {
  console.error('❌ Fehler:', err.message);
  process.exit(1);
});
