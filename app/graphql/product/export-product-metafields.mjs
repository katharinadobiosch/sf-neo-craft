/* eslint-env node */
import 'dotenv/config';
import fs from 'node:fs/promises';
import path from 'node:path';

const SHOP_DOMAIN =
  process.env.SHOPIFY_STORE_DOMAIN ||
  process.env.PUBLIC_STORE_DOMAIN ||
  process.env.SHOP_DOMAIN;

const ADMIN_TOKEN =
  process.env.SHOPIFY_ADMIN_TOKEN || process.env.ADMIN_API_TOKEN;

// passt bei dir zu den Types; kannst du anheben, wenn nötig
const API_VERSION = process.env.ADMIN_API_VERSION || '2025-01';

if (!SHOP_DOMAIN || !ADMIN_TOKEN) {
  console.error('Fehlt SHOP_DOMAIN oder ADMIN_TOKEN.', {
    SHOPIFY_STORE_DOMAIN: process.env.SHOPIFY_STORE_DOMAIN,
    PUBLIC_STORE_DOMAIN: process.env.PUBLIC_STORE_DOMAIN,
    SHOP_DOMAIN: process.env.SHOP_DOMAIN,
    SHOPIFY_ADMIN_TOKEN: !!process.env.SHOPIFY_ADMIN_TOKEN,
    ADMIN_API_TOKEN: !!process.env.ADMIN_API_TOKEN,
  });
  process.exit(1);
}

const endpoint = `https://${SHOP_DOMAIN}/admin/api/${API_VERSION}/graphql.json`;

// Query A: inkl. access{storefront}
const QUERY_WITH_ACCESS = `
  query defs($cursor: String, $ownerType: MetafieldOwnerType!) {
    metafieldDefinitions(first: 100, ownerType: $ownerType, after: $cursor) {
      edges {
        cursor
        node {
          namespace
          key
          name
          type { name }
          access { storefront }
        }
      }
      pageInfo { hasNextPage }
    }
  }
`;

// Query B: konservativ (falls A in älteren Shops knallt)
const QUERY_MINIMAL = `
  query defs($cursor: String, $ownerType: MetafieldOwnerType!) {
    metafieldDefinitions(first: 100, ownerType: $ownerType, after: $cursor) {
      edges {
        cursor
        node {
          namespace
          key
          name
          type { name }
        }
      }
      pageInfo { hasNextPage }
    }
  }
`;

async function gqlFetch(query, variables) {
  const res = await fetch(endpoint, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Shopify-Access-Token': ADMIN_TOKEN,
    },
    body: JSON.stringify({query, variables}),
  });
  const json = await res.json();
  if (json.errors) {
    const msg = json.errors.map((e) => e.message).join('; ');
    throw new Error(msg || 'GraphQL error');
  }
  return json.data;
}

async function fetchAllDefs(ownerType) {
  let cursor = null;
  let all = [];
  // zuerst mit access{}
  let query = QUERY_WITH_ACCESS;
  for (;;) {
    try {
      const data = await gqlFetch(query, {ownerType, cursor});
      const page = data.metafieldDefinitions;
      const nodes = page.edges.map((e) => ({...e.node, ownerType}));
      all.push(...nodes);
      if (!page.pageInfo.hasNextPage) break;
      cursor = page.edges.at(-1).cursor;
    } catch (e) {
      // fallback ohne access{}
      if (query === QUERY_MINIMAL) throw e;
      query = QUERY_MINIMAL;
      cursor = null;
      all = [];
    }
  }
  return all;
}

async function main() {
  const OUT_DIR = path.resolve('app/graphql/product');
  const ALL_FILE = path.join(OUT_DIR, 'metafield-defs-ALL.json');
  const PRODUCT_FILE = path.join(OUT_DIR, 'product-metafield-defs.json');
  const FRAGMENT_FILE = path.join(
    OUT_DIR,
    'product-metafields.fragment.graphql',
  );

  await fs.mkdir(OUT_DIR, {recursive: true});

  // 1) Alle OwnerTypes holen (hier reicht PRODUCT – kannst COLLECTION etc. ergänzen)
  const ownerType = 'PRODUCT';
  const allDefs = await fetchAllDefs(ownerType);

  await fs.writeFile(ALL_FILE, JSON.stringify(allDefs, null, 2), 'utf8');

  // 2) Nur PRODUCT-Definitionen
  const productDefs = allDefs.filter((d) => d.ownerType === 'PRODUCT');
  await fs.writeFile(
    PRODUCT_FILE,
    JSON.stringify(productDefs, null, 2),
    'utf8',
  );

  // 3) Fragment bauen – nur storefront: PUBLIC_READ
  const productStorefront = productDefs.filter(
    (d) => d?.access?.storefront === 'PUBLIC_READ',
  );

  const sorted = [
    ...productStorefront.filter((d) => d.namespace === 'custom'),
    ...productStorefront.filter((d) => d.namespace !== 'custom'),
  ];

  const identifiers = sorted
    .map(
      (d) =>
        `        {namespace: "${d.namespace}", key: "${d.key}"}${
          d.type?.name ? `  # ${d.type.name}` : ''
        }`,
    )
    .join('\n');

  const fragment = `# Generated by graphql/product/export-product-metafields.mjs
# Store: ${SHOP_DOMAIN}
# API: ${API_VERSION}
# OwnerType: PRODUCT
# Hinweis: nur Definitionen mit storefront: PUBLIC_READ

fragment ProductCustomMetafields on Product {
  # Liefert eine Liste von Metafeldern (Einträge können null sein,
  # wenn am Produkt kein Wert gesetzt ist)
  metafields(identifiers: [
${identifiers}
  ]) {
    namespace
    key
    type
    value

    # Einzel-Referenz (file_reference etc.)
    reference {
      __typename
      ... on Metaobject { id type handle fields { key type value } }
      ... on MediaImage { image { url altText } }
      ... on Video { sources { url mimeType } }
      ... on Model3d { sources { url mimeType } }
      ... on GenericFile { url mimeType }
    }

    # Listen-Referenzen
    references(first: 50) {
      nodes {
        __typename
        ... on Metaobject { id type handle fields { key type value } }
        ... on MediaImage { image { url altText } }
        ... on Video { sources { url mimeType } }
        ... on Model3d { sources { url mimeType } }
        ... on GenericFile { url mimeType }
      }
    }
  }
}
`;
  await fs.writeFile(FRAGMENT_FILE, fragment, 'utf8');

  console.log('✅ Export fertig');
  console.log('  →', path.relative(process.cwd(), ALL_FILE));
  console.log('  →', path.relative(process.cwd(), PRODUCT_FILE));
  console.log('  →', path.relative(process.cwd(), FRAGMENT_FILE));
}

main().catch((e) => {
  console.error('❌ Fehler:', e?.message || e);
  process.exit(1);
});
